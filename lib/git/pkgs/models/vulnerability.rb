# frozen_string_literal: true

require "time"

module Git
  module Pkgs
    module Models
      class Vulnerability < Sequel::Model
        one_to_many :vulnerability_packages, key: :vulnerability_id

        dataset_module do
          def by_severity(severity)
            where(severity: severity)
          end

          def critical
            by_severity("critical")
          end

          def high
            by_severity("high")
          end

          def medium
            by_severity("medium")
          end

          def low
            by_severity("low")
          end

          def not_withdrawn
            where(withdrawn_at: nil)
          end

          def stale(max_age_seconds = 86400)
            threshold = Time.now - max_age_seconds
            where { fetched_at < threshold }
          end

          def fresh(max_age_seconds = 86400)
            threshold = Time.now - max_age_seconds
            where { fetched_at >= threshold }
          end
        end

        def severity_level
          case severity&.downcase
          when "critical" then 4
          when "high" then 3
          when "medium" then 2
          when "low" then 1
          else 0
          end
        end

        def severity_display
          severity&.upcase || "UNKNOWN"
        end

        def withdrawn?
          !withdrawn_at.nil?
        end

        def aliases_list
          return [] if aliases.nil? || aliases.empty?

          aliases.split(",").map(&:strip)
        end

        # Create or update from OSV API response data.
        # Creates both the Vulnerability record and VulnerabilityPackage records
        # for each affected package.
        def self.from_osv(osv_data)
          vuln_id = osv_data["id"]
          severity_info = extract_severity(osv_data)

          vuln = update_or_create(
            { id: vuln_id },
            {
              aliases: extract_aliases(osv_data),
              severity: severity_info[:severity],
              cvss_score: severity_info[:score],
              cvss_vector: severity_info[:vector],
              summary: osv_data["summary"],
              details: osv_data["details"],
              published_at: parse_timestamp(osv_data["published"]),
              modified_at: parse_timestamp(osv_data["modified"]),
              withdrawn_at: parse_timestamp(osv_data["withdrawn"]),
              fetched_at: Time.now
            }
          )

          # Create VulnerabilityPackage records for each affected package
          (osv_data["affected"] || []).each do |affected|
            pkg = affected["package"]
            next unless pkg

            ecosystem = pkg["ecosystem"]
            name = pkg["name"]

            affected_range = build_affected_range(affected)
            fixed = extract_fixed_versions(affected)

            VulnerabilityPackage.update_or_create(
              { vulnerability_id: vuln_id, ecosystem: ecosystem, package_name: name },
              {
                affected_versions: affected_range,
                fixed_versions: fixed&.join(",")
              }
            )
          end

          vuln
        end

        def self.extract_aliases(osv_data)
          aliases = osv_data["aliases"] || []
          aliases.any? ? aliases.join(",") : nil
        end

        def self.extract_severity(osv_data)
          result = { severity: nil, score: nil, vector: nil }

          if osv_data["severity"]&.any?
            sev = osv_data["severity"].first
            result[:vector] = sev["score"]

            if sev["score"]&.include?("CVSS")
              result[:score] = parse_cvss_score(sev["score"])
              result[:severity] = score_to_severity(result[:score])
            end
          end

          # Check root-level database_specific (GHSA format)
          if osv_data["database_specific"]&.dig("severity")
            result[:severity] ||= normalize_severity(osv_data["database_specific"]["severity"])
          end

          # Check affected entries for database_specific severity
          osv_data["affected"]&.each do |affected|
            db_specific = affected["database_specific"]
            if db_specific && db_specific["severity"]
              result[:severity] ||= normalize_severity(db_specific["severity"])
            end
          end

          result
        end

        def self.normalize_severity(severity)
          return nil unless severity

          case severity.downcase
          when "critical" then "critical"
          when "high" then "high"
          when "moderate", "medium" then "medium"
          when "low" then "low"
          end
        end

        def self.parse_cvss_score(vector)
          return nil unless vector

          if vector.match?(/^\d+\.?\d*$/)
            return vector.to_f
          end

          return nil unless vector.include?("CVSS:")

          metrics = parse_cvss_metrics(vector)
          return nil if metrics.empty?

          estimate_cvss_score(metrics)
        end

        def self.parse_cvss_metrics(vector)
          metrics = {}
          vector.split("/").each do |part|
            key, value = part.split(":")
            metrics[key] = value if key && value
          end
          metrics
        end

        def self.estimate_cvss_score(metrics)
          impact_values = { "N" => 0, "L" => 1, "H" => 2 }
          c = impact_values[metrics["C"]] || 0
          i = impact_values[metrics["I"]] || 0
          a = impact_values[metrics["A"]] || 0
          max_impact = [c, i, a].max

          ac_easy = metrics["AC"] == "L"
          av_network = metrics["AV"] == "N"
          pr_none = metrics["PR"] == "N"
          ui_none = metrics["UI"] == "N"

          if max_impact == 2 && av_network && ac_easy && pr_none && ui_none
            9.8
          elsif max_impact == 2 && av_network && ac_easy
            8.1
          elsif max_impact == 2
            7.0
          elsif max_impact == 1 && av_network
            5.3
          elsif max_impact == 1
            4.0
          elsif max_impact == 0
            0.0
          else
            5.0
          end
        end

        def self.score_to_severity(score)
          return nil unless score

          case score
          when 9.0..10.0 then "critical"
          when 7.0...9.0 then "high"
          when 4.0...7.0 then "medium"
          when 0.0...4.0 then "low"
          end
        end

        def self.build_affected_range(affected)
          return nil unless affected

          ranges = affected["ranges"] || []
          versions = affected["versions"] || []

          return versions.join(",") if versions.any? && ranges.empty?

          range_parts = ranges.flat_map do |range|
            events = range["events"] || []
            build_range_from_events(events)
          end

          range_parts.compact.join(" || ")
        end

        def self.build_range_from_events(events)
          ranges = []
          current_introduced = nil

          events.each do |event|
            if event["introduced"]
              current_introduced = event["introduced"]
            elsif event["fixed"] && current_introduced
              if current_introduced == "0"
                ranges << "<#{event["fixed"]}"
              else
                ranges << ">=#{current_introduced} <#{event["fixed"]}"
              end
              current_introduced = nil
            elsif event["last_affected"] && current_introduced
              if current_introduced == "0"
                ranges << "<=#{event["last_affected"]}"
              else
                ranges << ">=#{current_introduced} <=#{event["last_affected"]}"
              end
              current_introduced = nil
            end
          end

          if current_introduced
            ranges << if current_introduced == "0"
                        ">=0"
                      else
                        ">=#{current_introduced}"
                      end
          end

          ranges
        end

        def self.extract_fixed_versions(affected)
          return nil unless affected

          fixed = []
          (affected["ranges"] || []).each do |range|
            (range["events"] || []).each do |event|
              fixed << event["fixed"] if event["fixed"]
            end
          end

          fixed.uniq.empty? ? nil : fixed.uniq
        end

        def self.parse_timestamp(str)
          return nil unless str

          Time.parse(str)
        rescue ArgumentError
          nil
        end
      end
    end
  end
end
