# frozen_string_literal: true

require "test_helper"
require "webmock/minitest"

class Git::Pkgs::TestVulnerability < Minitest::Test
  include TestHelpers

  def setup
    create_test_repo
    add_file("README.md", "# Test")
    commit("Initial commit")

    @git_dir = File.join(@test_dir, ".git")
    Git::Pkgs::Database.connect(@git_dir)
    Git::Pkgs::Database.create_schema
  end

  def teardown
    cleanup_test_repo
  end

  def test_create_vulnerability
    vuln = Git::Pkgs::Models::Vulnerability.create(
      id: "CVE-2024-1234",
      severity: "high",
      summary: "Prototype pollution",
      fetched_at: Time.now
    )

    assert_equal "CVE-2024-1234", vuln.id
    assert_equal "high", vuln.severity
  end

  def test_severity_scopes
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-1", severity: "critical", fetched_at: Time.now)
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-2", severity: "high", fetched_at: Time.now)
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-3", severity: "medium", fetched_at: Time.now)
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-4", severity: "low", fetched_at: Time.now)

    assert_equal 1, Git::Pkgs::Models::Vulnerability.critical.count
    assert_equal 1, Git::Pkgs::Models::Vulnerability.high.count
    assert_equal 1, Git::Pkgs::Models::Vulnerability.medium.count
    assert_equal 1, Git::Pkgs::Models::Vulnerability.low.count
  end

  def test_not_withdrawn_scope
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-1", fetched_at: Time.now, withdrawn_at: nil)
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-2", fetched_at: Time.now, withdrawn_at: Time.now)

    assert_equal 1, Git::Pkgs::Models::Vulnerability.not_withdrawn.count
    assert_equal "CVE-1", Git::Pkgs::Models::Vulnerability.not_withdrawn.first.id
  end

  def test_severity_level
    critical = Git::Pkgs::Models::Vulnerability.new(severity: "critical")
    high = Git::Pkgs::Models::Vulnerability.new(severity: "high")
    medium = Git::Pkgs::Models::Vulnerability.new(severity: "medium")
    low = Git::Pkgs::Models::Vulnerability.new(severity: "low")
    unknown = Git::Pkgs::Models::Vulnerability.new(severity: nil)

    assert_equal 4, critical.severity_level
    assert_equal 3, high.severity_level
    assert_equal 2, medium.severity_level
    assert_equal 1, low.severity_level
    assert_equal 0, unknown.severity_level
  end

  def test_severity_display
    vuln = Git::Pkgs::Models::Vulnerability.new(severity: "high")
    assert_equal "HIGH", vuln.severity_display

    vuln_nil = Git::Pkgs::Models::Vulnerability.new(severity: nil)
    assert_equal "UNKNOWN", vuln_nil.severity_display
  end

  def test_withdrawn
    vuln = Git::Pkgs::Models::Vulnerability.new(withdrawn_at: nil)
    refute vuln.withdrawn?

    vuln_withdrawn = Git::Pkgs::Models::Vulnerability.new(withdrawn_at: Time.now)
    assert vuln_withdrawn.withdrawn?
  end

  def test_aliases_list
    vuln = Git::Pkgs::Models::Vulnerability.new(aliases: "CVE-2024-1234, GHSA-xxxx")
    assert_equal ["CVE-2024-1234", "GHSA-xxxx"], vuln.aliases_list

    vuln_nil = Git::Pkgs::Models::Vulnerability.new(aliases: nil)
    assert_equal [], vuln_nil.aliases_list
  end

  def test_stale_scope
    old_time = Time.now - 100_000
    Git::Pkgs::Models::Vulnerability.create(
      id: "CVE-OLD",
      fetched_at: old_time
    )

    Git::Pkgs::Models::Vulnerability.create(
      id: "CVE-NEW",
      fetched_at: Time.now
    )

    stale = Git::Pkgs::Models::Vulnerability.stale(86400)
    assert_equal 1, stale.count
    assert_equal "CVE-OLD", stale.first.id
  end

  def test_from_osv_creates_vulnerability_and_packages
    osv_data = {
      "id" => "GHSA-test",
      "summary" => "Test vulnerability",
      "details" => "Detailed description",
      "published" => "2024-01-15T00:00:00Z",
      "modified" => "2024-01-16T00:00:00Z",
      "aliases" => ["CVE-2024-1234"],
      "affected" => [
        {
          "package" => {
            "name" => "lodash",
            "ecosystem" => "npm"
          },
          "ranges" => [
            {
              "type" => "ECOSYSTEM",
              "events" => [
                { "introduced" => "0" },
                { "fixed" => "4.17.21" }
              ]
            }
          ],
          "database_specific" => {
            "severity" => "HIGH"
          }
        }
      ]
    }

    vuln = Git::Pkgs::Models::Vulnerability.from_osv(osv_data)

    assert_equal "GHSA-test", vuln.id
    assert_equal "high", vuln.severity
    assert_equal "Test vulnerability", vuln.summary
    assert_equal "CVE-2024-1234", vuln.aliases

    vuln_pkgs = Git::Pkgs::Models::VulnerabilityPackage.where(vulnerability_id: "GHSA-test")
    assert_equal 1, vuln_pkgs.count

    vp = vuln_pkgs.first
    assert_equal "npm", vp.ecosystem
    assert_equal "lodash", vp.package_name
    assert_includes vp.affected_versions, "<4.17.21"
    assert_equal "4.17.21", vp.fixed_versions
  end

  def test_from_osv_creates_multiple_package_entries
    osv_data = {
      "id" => "GHSA-multi",
      "summary" => "Affects multiple packages",
      "affected" => [
        {
          "package" => { "name" => "lodash", "ecosystem" => "npm" },
          "ranges" => [{ "events" => [{ "introduced" => "0" }, { "fixed" => "4.17.21" }] }]
        },
        {
          "package" => { "name" => "lodash-es", "ecosystem" => "npm" },
          "ranges" => [{ "events" => [{ "introduced" => "0" }, { "fixed" => "4.17.21" }] }]
        }
      ]
    }

    Git::Pkgs::Models::Vulnerability.from_osv(osv_data)

    vuln_pkgs = Git::Pkgs::Models::VulnerabilityPackage.where(vulnerability_id: "GHSA-multi")
    assert_equal 2, vuln_pkgs.count

    package_names = vuln_pkgs.map(&:package_name).sort
    assert_equal ["lodash", "lodash-es"], package_names
  end

  def test_from_osv_updates_existing
    Git::Pkgs::Models::Vulnerability.create(
      id: "GHSA-test",
      summary: "Old summary",
      fetched_at: Time.now - 86400
    )

    osv_data = {
      "id" => "GHSA-test",
      "summary" => "New summary",
      "affected" => [
        {
          "package" => { "name" => "lodash", "ecosystem" => "npm" },
          "database_specific" => { "severity" => "CRITICAL" }
        }
      ]
    }

    vuln = Git::Pkgs::Models::Vulnerability.from_osv(osv_data)

    assert_equal 1, Git::Pkgs::Models::Vulnerability.count
    assert_equal "New summary", vuln.summary
    assert_equal "critical", vuln.severity
  end

  def test_from_osv_handles_withdrawn
    osv_data = {
      "id" => "GHSA-withdrawn",
      "summary" => "Withdrawn vulnerability",
      "withdrawn" => "2024-02-01T00:00:00Z",
      "affected" => []
    }

    vuln = Git::Pkgs::Models::Vulnerability.from_osv(osv_data)

    assert vuln.withdrawn?
    assert_equal 2024, vuln.withdrawn_at.year
  end

  def test_build_range_from_events_introduced_and_fixed
    events = [
      { "introduced" => "1.0.0" },
      { "fixed" => "1.2.3" }
    ]

    ranges = Git::Pkgs::Models::Vulnerability.build_range_from_events(events)
    assert_equal [">=1.0.0 <1.2.3"], ranges
  end

  def test_build_range_from_events_zero_introduced
    events = [
      { "introduced" => "0" },
      { "fixed" => "2.0.0" }
    ]

    ranges = Git::Pkgs::Models::Vulnerability.build_range_from_events(events)
    assert_equal ["<2.0.0"], ranges
  end

  def test_build_range_from_events_open_ended
    events = [
      { "introduced" => "3.0.0" }
    ]

    ranges = Git::Pkgs::Models::Vulnerability.build_range_from_events(events)
    assert_equal [">=3.0.0"], ranges
  end

  def test_build_range_from_events_last_affected
    events = [
      { "introduced" => "1.0.0" },
      { "last_affected" => "1.5.0" }
    ]

    ranges = Git::Pkgs::Models::Vulnerability.build_range_from_events(events)
    assert_equal [">=1.0.0 <=1.5.0"], ranges
  end
end

class Git::Pkgs::TestVulnerabilityPackage < Minitest::Test
  include TestHelpers

  def setup
    create_test_repo
    add_file("README.md", "# Test")
    commit("Initial commit")

    @git_dir = File.join(@test_dir, ".git")
    Git::Pkgs::Database.connect(@git_dir)
    Git::Pkgs::Database.create_schema
  end

  def teardown
    cleanup_test_repo
  end

  def test_create_vulnerability_package
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-1", fetched_at: Time.now)

    vp = Git::Pkgs::Models::VulnerabilityPackage.create(
      vulnerability_id: "CVE-1",
      ecosystem: "npm",
      package_name: "lodash",
      affected_versions: "<4.17.21",
      fixed_versions: "4.17.21"
    )

    assert_equal "CVE-1", vp.vulnerability_id
    assert_equal "npm", vp.ecosystem
    assert_equal "lodash", vp.package_name
  end

  def test_for_package_scope
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-1", fetched_at: Time.now)
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-2", fetched_at: Time.now)

    Git::Pkgs::Models::VulnerabilityPackage.create(
      vulnerability_id: "CVE-1",
      ecosystem: "npm",
      package_name: "lodash"
    )

    Git::Pkgs::Models::VulnerabilityPackage.create(
      vulnerability_id: "CVE-2",
      ecosystem: "npm",
      package_name: "express"
    )

    vulns = Git::Pkgs::Models::VulnerabilityPackage.for_package("npm", "lodash")
    assert_equal 1, vulns.count
    assert_equal "CVE-1", vulns.first.vulnerability_id
  end

  def test_fixed_versions_list
    vp = Git::Pkgs::Models::VulnerabilityPackage.new(fixed_versions: "1.2.3, 2.0.0, 2.1.0")
    assert_equal ["1.2.3", "2.0.0", "2.1.0"], vp.fixed_versions_list

    vp_nil = Git::Pkgs::Models::VulnerabilityPackage.new(fixed_versions: nil)
    assert_equal [], vp_nil.fixed_versions_list
  end

  def test_affects_version_simple_range
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-1", fetched_at: Time.now)

    vp = Git::Pkgs::Models::VulnerabilityPackage.create(
      vulnerability_id: "CVE-1",
      ecosystem: "npm",
      package_name: "lodash",
      affected_versions: "<4.17.21"
    )

    assert vp.affects_version?("4.17.15")
    assert vp.affects_version?("4.17.20")
    refute vp.affects_version?("4.17.21")
    refute vp.affects_version?("5.0.0")
  end

  def test_affects_version_nil_range
    vp = Git::Pkgs::Models::VulnerabilityPackage.new(affected_versions: nil)
    refute vp.affects_version?("1.0.0")

    vp_empty = Git::Pkgs::Models::VulnerabilityPackage.new(affected_versions: "")
    refute vp_empty.affects_version?("1.0.0")
  end

  def test_affects_version_handles_invalid_range
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-1", fetched_at: Time.now)

    vp = Git::Pkgs::Models::VulnerabilityPackage.create(
      vulnerability_id: "CVE-1",
      ecosystem: "npm",
      package_name: "lodash",
      affected_versions: ">= 0"  # Invalid semver range
    )

    # Should return true (assume affected) when range is unparseable
    assert vp.affects_version?("4.17.0")
  end

  def test_affects_version_handles_nil_version
    vp = Git::Pkgs::Models::VulnerabilityPackage.new(
      ecosystem: "npm",
      package_name: "lodash",
      affected_versions: "<4.17.21"
    )

    refute vp.affects_version?(nil)
    refute vp.affects_version?("")
  end

  def test_affects_version_correctly_handles_bounded_range
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-1", fetched_at: Time.now)

    vp = Git::Pkgs::Models::VulnerabilityPackage.create(
      vulnerability_id: "CVE-1",
      ecosystem: "RubyGems",
      package_name: "actionpack",
      affected_versions: ">=7.1.0 <7.1.3.1"
    )

    # 8.1.1 is NOT in the range >=7.1.0 <7.1.3.1
    refute vp.affects_version?("8.1.1"), "8.1.1 should NOT be affected by >=7.1.0 <7.1.3.1"

    # 7.1.2 IS in the range
    assert vp.affects_version?("7.1.2"), "7.1.2 should be affected by >=7.1.0 <7.1.3.1"

    # 7.1.3.1 is NOT in the range (fixed version)
    refute vp.affects_version?("7.1.3.1"), "7.1.3.1 should NOT be affected (it's the fixed version)"
  end

  def test_vulnerability_association
    Git::Pkgs::Models::Vulnerability.create(id: "CVE-1", severity: "high", fetched_at: Time.now)

    vp = Git::Pkgs::Models::VulnerabilityPackage.create(
      vulnerability_id: "CVE-1",
      ecosystem: "npm",
      package_name: "lodash"
    )

    assert_equal "CVE-1", vp.vulnerability.id
    assert_equal "high", vp.vulnerability.severity
  end

  def test_ensure_vulns_synced_with_distinct_query
    # This tests that ensure_vulns_synced works with SQLite which doesn't support DISTINCT ON
    # Create some dependency changes with duplicate ecosystem/name pairs
    manifest = Git::Pkgs::Models::Manifest.create(path: "package.json", ecosystem: "npm")
    commit1 = Git::Pkgs::Models::Commit.create(sha: "abc123", committed_at: Time.now)
    commit2 = Git::Pkgs::Models::Commit.create(sha: "def456", committed_at: Time.now)

    Git::Pkgs::Models::DependencyChange.create(
      commit_id: commit1.id,
      manifest_id: manifest.id,
      name: "lodash",
      ecosystem: "npm",
      change_type: "added",
      requirement: "4.17.0"
    )

    Git::Pkgs::Models::DependencyChange.create(
      commit_id: commit2.id,
      manifest_id: manifest.id,
      name: "lodash",
      ecosystem: "npm",
      change_type: "modified",
      requirement: "4.17.21"
    )

    # Create a mock class that includes Vulns::Base to test ensure_vulns_synced
    test_class = Class.new do
      include Git::Pkgs::Commands::Vulns::Base
      def initialize
        @options = {}
      end
    end

    handler = test_class.new

    # This should not raise an error about DISTINCT ON
    # It will try to sync but we stub the API call
    WebMock.stub_request(:post, "https://api.osv.dev/v1/querybatch")
      .to_return(status: 200, body: '{"results": [{"vulns": []}]}')

    # This will raise Sequel::InvalidOperation if DISTINCT ON is used on SQLite
    handler.ensure_vulns_synced

    # If we get here without raising, the test passes
    assert true
  end

  def test_vulns_diff_parses_two_refs_correctly
    # Test that vulns diff passes both refs to the handler correctly
    vulns = Git::Pkgs::Commands::VulnsCommand.new(["diff", "abc123", "def456"])

    # Access the parsed args that would be passed to VulnsDiff
    # The @args should contain both refs after parse_options
    args = vulns.instance_variable_get(:@args)

    # Both refs should be in args, not consumed by options[:ref]
    assert_includes args, "abc123"
    assert_includes args, "def456"
  end

  def test_compute_dependencies_at_commit_with_branch_join
    # Tests that commit_ids query properly qualifies column names
    # when joining commits and branch_commits tables
    branch = Git::Pkgs::Models::Branch.create(name: "main")
    commit1 = Git::Pkgs::Models::Commit.create(sha: "abc123", committed_at: Time.now - 86400)
    commit2 = Git::Pkgs::Models::Commit.create(sha: "def456", committed_at: Time.now)
    branch.add_commit(commit1)
    branch.add_commit(commit2)

    manifest = Git::Pkgs::Models::Manifest.create(path: "package.json", ecosystem: "npm")

    Git::Pkgs::Models::DependencySnapshot.create(
      commit_id: commit1.id,
      manifest_id: manifest.id,
      name: "lodash",
      ecosystem: "npm",
      requirement: "4.17.0",
      dependency_type: "runtime"
    )

    Git::Pkgs::Models::DependencyChange.create(
      commit_id: commit2.id,
      manifest_id: manifest.id,
      name: "lodash",
      ecosystem: "npm",
      change_type: "modified",
      requirement: "4.17.21"
    )

    test_class = Class.new do
      include Git::Pkgs::Commands::Vulns::Base
      def initialize(branch_name)
        @options = { branch: branch_name }
      end
    end

    handler = test_class.new("main")

    # This should not raise "ambiguous column name: id" error
    deps = handler.compute_dependencies_at_commit(commit2, nil)

    assert_equal 1, deps.size
    assert_equal "lodash", deps.first[:name]
    assert_equal "4.17.21", deps.first[:requirement]
  end
end
